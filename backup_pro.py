import os import zipfile import json from datetime import datetime from Crypto.Cipher import AES from Crypto.Util.Padding import pad import schedule import time import tkinter as tk from tkinter import filedialog, messagebox # Google Drive from googleapiclient.discovery import build from googleapiclient.http import MediaFileUpload from google.oauth2 import service_account # Load config with open("config.json", "r", encoding="utf-8") as f: config = json.load(f) SOURCE = config["source_folder"] BACKUP_DIR = config["backup_folder"] EXCLUDE = config.get("exclude", []) COMPRESS = config.get("compress", True) ENCRYPT = config.get("encrypt", True) KEY = config.get("encryption_key", "").encode() # 16/24/32 bytes DRIVE_CONFIG = config.get("google_drive", {}) SCHEDULE_TYPE = config.get("schedule", "none") os.makedirs(BACKUP_DIR, exist_ok=True) def should_exclude(path): return any(item in path for item in EXCLUDE) def encrypt_file(file_path, key): with open(file_path, "rb") as f: data = f.read() cipher = AES.new(key, AES.MODE_CBC) ciphertext = cipher.iv + cipher.encrypt(pad(data, AES.block_size)) enc_path = file_path + ".enc" with open(enc_path, "wb") as f: f.write(ciphertext) return enc_path def upload_to_drive(file_path): if not DRIVE_CONFIG.get("enable"): return creds = service_account.Credentials.from_service_account_file( DRIVE_CONFIG["credentials_file"], scopes=["https://www.googleapis.com/auth/drive"] ) service = build('drive', 'v3', credentials=creds) file_metadata = {'name': os.path.basename(file_path), 'parents':[DRIVE_CONFIG["folder_id"]]} media = MediaFileUpload(file_path, resumable=True) service.files().create(body=file_metadata, media_body=media, fields='id').execute() print(f"Uploaded to Google Drive: {file_path}") def create_backup(): date = datetime.now().strftime("%Y-%m-%d_%H-%M-%S") backup_name = f"backup_{date}" zip_path = os.path.join(BACKUP_DIR, backup_name + ".zip") with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zipf: for foldername, subfolders, filenames in os.walk(SOURCE): if should_exclude(foldername): continue for filename in filenames: file_path = os.path.join(foldername, filename) arcname = os.path.relpath(file_path, SOURCE) zipf.write(file_path, arcname) print(f"Backup created: {zip_path}") if ENCRYPT: zip_path = encrypt_file(zip_path, KEY) print(f"Backup encrypted: {zip_path}") upload_to_drive(zip_path) # GUI def select_folder(entry): folder = filedialog.askdirectory() if folder: entry.delete(0, tk.END) entry.insert(0, folder) def run_backup_gui(): create_backup() messagebox.showinfo("Backup", "Backup completed successfully!") def start_gui(): root = tk.Tk() root.title("SmartBackup Pro") tk.Label(root, text="Source Folder:").grid(row=0, column=0) src_entry = tk.Entry(root, width=50) src_entry.grid(row=0, column=1) tk.Button(root, text="Browse", command=lambda: select_folder(src_entry)).grid(row=0, column=2) tk.Label(root, text="Backup Folder:").grid(row=1, column=0) dest_entry = tk.Entry(root, width=50) dest_entry.grid(row=1, column=1) tk.Button(root, text="Browse", command=lambda: select_folder(dest_entry)).grid(row=1, column=2) tk.Button(root, text="Run Backup", command=run_backup_gui).grid(row=2, column=1) root.mainloop() # Scheduler def schedule_backup(): if SCHEDULE_TYPE == "daily": schedule.every().day.at("02:00").do(create_backup) elif SCHEDULE_TYPE == "weekly": schedule.every().monday.at("02:00").do(create_backup) else: return while True: schedule.run_pending() time.sleep(60) # Main if __name__ == "__main__": start_gui() # Uncomment below to run as scheduler # schedule_backup()
